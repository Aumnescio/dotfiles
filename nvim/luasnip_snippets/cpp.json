{
  "!init": {
    "prefix": "!init",
    "description": "Snippet for: Base cpp template.",
    "body": [
      "#include <iostream>",
      "",
      "int main() {",
      "\t$0",
      "\treturn 0;",
      "\\}"
    ]
  },
  "#pragma": {
    "prefix": "#pragma",
    "description": "Snippet for: Base hpp template.",
    "body": "#pragma once"
  },
  "main": {
    "prefix": "main",
    "description": "Snippet for: main.",
    "body": [
      "int main(int argc, char **argv) {",
      "\t$0",
      "\treturn 0;",
      "\\}"
    ]
  },
  "using_std": {
    "prefix": "using_std",
    "description": "Snippet for: using namespace std.",
    "body": "using namespace std;"
  },
  "include_std": {
    "prefix": "include_std",
    "description": "Snippet for: #include <.",
    "body": "#include <$0"
  },
  "include_local": {
    "prefix": "include_local",
    "description": "Snippet for: #include.",
    "body": "#include \"$0"
  },
  "fn": {
    "prefix": "fn",
    "description": "Snippet for: Generic function.",
    "body": [
      "$1($2) {",
      "\t$0",
      "\\}"
    ]
  },
  "fn_void": {
    "prefix": "fn_void",
    "description": "Snippet for: Void function.",
    "body": [
      "void $1($2) {",
      "\t$0",
      "\\}"
    ]
  },
  "fn_int": {
    "prefix": "fn_int",
    "description": "Snippet for: int function.",
    "body": [
      "int $1($2) {",
      "\t$0",
      "\\}"
    ]
  },
  "fn_double": {
    "prefix": "fn_double",
    "description": "Snippet for: double function.",
    "body": [
      "double $1($2) {",
      "\t$0",
      "\\}"
    ]
  },
  "virtual": {
    "prefix": "virtual",
    "description": "Snippet for: virtual.",
    "body": "virtual"
  },
  "pure_method": {
    "prefix": "pure_method",
    "description": "Snippet for: pure virtual class function.",
    "body": "virtual $1($2) = 0;"
  },
  "new": {
    "prefix": "new",
    "description": "Snippet for: new.",
    "body": "new$0"
  },
  "delete": {
    "prefix": "delete",
    "description": "Snippet for: delete.",
    "body": "delete$0"
  },
  "return": {
    "prefix": "return",
    "description": "Snippet for: return.",
    "body": "return $0;"
  },
  "const": {
    "prefix": "const",
    "description": "Snippet for: const.",
    "body": "const$0"
  },
  "var_uniq": {
    "prefix": "var_uniq",
    "description": "Snippet for: `unique_pointer` variable.",
    "body": "auto $1 = std::make_unique<$2>($0);"
  },
  "var_shared": {
    "prefix": "var_shared",
    "description": "Snippet for: `shared_pointer` variable.",
    "body": "auto $1 = std::make_shared<$2>($0);"
  },
  "bool": {
    "prefix": "bool",
    "description": "Keyword for boolean type. (true/false)",
    "body": "bool $0"
  },
  "true": {
    "prefix": "true",
    "description": "Snippet for: true.",
    "body": "true$0"
  },
  "false": {
    "prefix": "false",
    "description": "Snippet for: false.",
    "body": "false$0"
  },
  "int": {
    "prefix": "int",
    "description": "Basic integer type. (i16 minimum, but most likely i32)",
    "body": "int $0"
  },
  "long": {
    "prefix": "long",
    "description": "At least 32 bit integer. (i32)",
    "body": "long $0"
  },
  "long_long": {
    "prefix": "long_long",
    "description": "At least 64 bit integer. (i64)",
    "body": "long long $0"
  },
  "char": {
    "prefix": "char",
    "description": "Type for character representation.",
    "body": "char $0"
  },
  "float": {
    "prefix": "float",
    "description": "Snippet for: float.",
    "body": "float $0"
  },
  "double": {
    "prefix": "double",
    "description": "Snippet for: double.",
    "body": "double $0"
  },
  "and": {
    "prefix": "and",
    "description": "'and' is an alternative to && (Logical AND operator)",
    "body": "and $0"
  },
  "or": {
    "prefix": "or",
    "description": "'or' is an alternative to || (Logical OR operator)",
    "body": "or $0"
  },
  "not": {
    "prefix": "not",
    "description": "Snippet for: not.",
    "body": "not $0"
  },
  "void": {
    "prefix": "void",
    "description": "Snippet for: void.",
    "body": "void $0"
  },
  "static": {
    "prefix": "static",
    "description": "Snippet for: static.",
    "body": "static $0"
  },
  "auto": {
    "prefix": "auto",
    "description": "Automatically infer type.",
    "body": "auto $0"
  },
  "while": {
    "prefix": "while",
    "description": "Snippet for: while loop.",
    "body": [
      "while ($1) {",
      "\t$0",
      "\\}"
    ]
  },
  "do_while": {
    "prefix": "do_while",
    "description": "Snippet for: do-while loop.",
    "body": [
      "do {",
      "\t$1",
      "\\} while ($0);"
    ]
  },
  "for": {
    "prefix": "for",
    "description": "Snippet for: Basic for loop.",
    "body": [
      "for ($1; $2; $3) {",
      "\t$0",
      "\\}"
    ]
  },
  "for_each": {
    "prefix": "for_each",
    "description": "Snippet for: For each loop.",
    "body": [
      "for ($1 : $2) {",
      "\t$0",
      "\\}"
    ]
  },
  "for_each_auto": {
    "prefix": "for_each_auto",
    "description": "Snippet for: For each loop.",
    "body": [
      "for (auto& $1 : $2) {",
      "\t$0",
      "\\}"
    ]
  },
  "if": {
    "prefix": "if",
    "description": "Snippet for: if.",
    "body": "if ($1) {$0\\}"
  },
  "else": {
    "prefix": "else",
    "description": "Snippet for: else.",
    "body": "else {$0\\}"
  },
  "else_if": {
    "prefix": "else_if",
    "description": "Snippet for: else if.",
    "body": "else if ($1) {$0\\}"
  },
  "switch": {
    "prefix": "switch",
    "description": "Transfers control to one of several statements, depending on the value of a condition.",
    "body": [
      "switch($1) {",
      "\tcase $2:",
      "\t\t$3",
      "\t\tbreak;",
      "\tdefault:",
      "\t\t$0",
      "\\}"
    ]
  },
  "case": {
    "prefix": "case",
    "description": "case <constant-expression> : <statement>",
    "body": [
      "case $1:",
      "\t$0",
      "\tbreak;"
    ]
  },
  "default": {
    "prefix": "default",
    "description": "default : <statement>",
    "body": "default:$0"
  },
  "break": {
    "prefix": "break",
    "description": "Causes the enclosing for, range-for, while or do-while loop or switch statement to terminate.",
    "body": "break$0"
  },
  "continue": {
    "prefix": "continue",
    "description": "Snippet for: continue.",
    "body": "continue$0"
  },
  "try": {
    "prefix": "try",
    "description": "Snippet for: try.",
    "body": "try {$0\\}"
  },
  "catch": {
    "prefix": "catch",
    "description": "Snippet for: catch.",
    "body": "catch ($1) {$0\\}"
  },
  "throw": {
    "prefix": "throw",
    "description": "Snippet for: throw.",
    "body": "throw$0"
  },
  "enum": {
    "prefix": "enum",
    "description": "Snippet for: enum.",
    "body": "enum $1 {$0\\};"
  },
  "namespace": {
    "prefix": "namespace",
    "description": "Snippet for: namespace.",
    "body": "namespace$0"
  },
  "cout": {
    "prefix": "cout",
    "description": "Snippet for: cout.",
    "body": "std::cout << \"$0\\n\";"
  },
  "cout_variable": {
    "prefix": "cout_variable",
    "description": "Snippet for: cout.",
    "body": "std::cout << $0 << \"\\n\";"
  },
  "cout_end": {
    "prefix": "cout_end",
    "description": "Snippet for: cout endl.",
    "body": "std::cout << std::endl;"
  },
  "cout_info": {
    "prefix": "cout_info",
    "description": "Snippet for: cout info.",
    "body": "std::cout << \"|> INFO: $0\\n\";"
  },
  "cout_debug": {
    "prefix": "cout_debug",
    "description": "Snippet for: cout debug.",
    "body": "std::cout << \"|> DEBUG: $0\\n\";"
  },
  "cout_error": {
    "prefix": "cout_error",
    "description": "Snippet for: cout error.",
    "body": "std::cout << \"|> ERROR: $0\\n\";"
  },
  "cin_simple": {
    "prefix": "cin_simple",
    "description": "Snippet for: cin.",
    "body": "std::cin >> $0;"
  },
  "stdvec": {
    "prefix": "stdvec",
    "description": "Snippet for: std::vector.",
    "body": "std::vector<$0> ",
    "luasnip": {
      "autotrigger": true
    }
  },
  "stdstr": {
    "prefix": "stdstr",
    "description": "Snippet for: std::string.",
    "body": "std::string$0",
    "luasnip": {
      "autotrigger": true
    }
  },
  "stdif": {
    "prefix": "stdif",
    "description": "Snippet for: std::ifstream.",
    "body": "std::ifstream $0",
    "luasnip": {
      "autotrigger": true
    }
  },
  "stdof": {
    "prefix": "stdof",
    "description": "Snippet for: std::ofstream.",
    "body": "std::ofstream $0",
    "luasnip": {
      "autotrigger": true
    }
  },
  "vector_std": {
    "prefix": "vector_std",
    "description": "Snippet for: std::vector.",
    "body": "std::vector<$0>"
  },
  "reverse_std": {
    "prefix": "reverse_std",
    "description": "Reverse a sequence in place.",
    "body": "std::reverse($1.begin(), $1.end());"
  },
  "stdrev": {
    "prefix": "stdrev",
    "description": "Reverse a sequence in place.",
    "body": "std::reverse($1.begin(), $1.end());",
    "luasnip": {
      "autotrigger": true
    }
  },
  "op<<": {
    "prefix": "op<<",
    "description": "Snippet for: '<<' operator overloading function.",
    "body": [
      "friend std::ostream& operator<<(std::ostream& os, const $1& $2) {",
      "\tos << $0;",
      "\treturn os;",
      "\\}"
    ]
  },
  "write_file_aum_func": {
    "prefix": "write_file_aum_func",
    "description": "Snippet for: Function for writing a string to a file.",
    "body": [
      "// Write string to file. (Clears previous file contents)",
      "bool writeToFile(std::string file_name, std::string text_to_write) {",
      "",
      "\t// File",
      "\tstd::ofstream file(file_name, std::ios::trunc);",
      "",
      "\t// Early exit if can't open.",
      "\tif (!file.is_open()) {",
      "\t\treturn false;",
      "\t\\}",
      "",
      "\t// Write to file.",
      "\tfile << text_to_write;",
      "",
      "\t// Print action message.",
      "\tstd::cout << \"Wrote to: \" << file_name << std::endl;",
      "",
      "\t// Return without errors.",
      "\treturn true;",
      "\\}"
    ]
  },
  "read_file_aum_func": {
    "prefix": "read_file_aum_func",
    "description": "Snippet for: Function for reading a file into a string.",
    "body": [
      "// Read file contents into string.",
      "std::string readFile(std::string file_name) {",
      "",
      "\t// Input file.",
      "\tstd::ifstream file(file_name);",
      "",
      "\t// Print error, return empty string.",
      "\tif (!file.is_open()) {",
      "\t\tprintf(\"Unable to read file: No such file or directory. (File: %s, \"",
      "\t\t\t   \"Line: %d)\",",
      "\t\t\t   __FILE__, __LINE__);",
      "\t\treturn \"\";",
      "\t\\}",
      "",
      "\tstd::string file_contents;",
      "\tstd::string line;",
      "",
      "\tauto process = [&](std::string line) {",
      "\t\tfile_contents += line;",
      "\t\tfile_contents.push_back('\\n');",
      "\t\\};",
      "",
      "\twhile (std::getline(file, line)) {",
      "\t\tprocess(line);",
      "",
      "\t\tif (file.fail()) {",
      "\t\t\tprintf(\"Error reading file contents. (File: %s, \"",
      "\t\t\t\t   \"Line: %d)\",",
      "\t\t\t\t   __FILE__, __LINE__);",
      "\t\t\treturn \"\";",
      "\t\t\\}",
      "\t\\}",
      "",
      "\tstd::cout << \"File\"",
      "\t\t\t  << \"'\" << file_name << \"'\"",
      "\t\t\t  << \"read successfully.\" << std::endl;",
      "",
      "\treturn file_contents;",
      "\\}"
    ]
  }
}
